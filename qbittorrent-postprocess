#!/bin/bash
version="0.1.0"
#
# This is an optional arguments-only example of Argbash potential
#
# ARG_OPTIONAL_SINGLE([qb_name],[N],[torrent name])
# ARG_OPTIONAL_SINGLE([qb_category],[L],[torrent category])
# ARG_OPTIONAL_SINGLE([qb_tags],[G],[separated by comma])
# ARG_OPTIONAL_SINGLE([qb_content],[F],[content path, same as root for multifile torrent])
# ARG_OPTIONAL_SINGLE([qb_root],[R],[root path, first torrent subdirectory path])
# ARG_OPTIONAL_SINGLE([qb_save],[D],[save path])
# ARG_OPTIONAL_SINGLE([qb_num],[C],[number of files])
# ARG_OPTIONAL_SINGLE([qb_size],[Z],[torrent size (bytes)])
# ARG_OPTIONAL_SINGLE([qb_tracker],[T],[current tracker])
# ARG_OPTIONAL_SINGLE([qb_hash],[I],[torrent info hash])
# ARG_USE_ENV([SCRIPTS],[/scripts],[the default mount path for scripts])

# ARG_USE_PROG([FILEBOT], [/usr/bin/filebot], [filebot executable])

# ARG_HELP([qbittorrent filebot postprocess script])
# ARG_VERSION([echo "$(basename "$0")" v$version])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([

### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###

# When called, the process ends.
# Args:
# 	$1: The exit message (print to stderr)
# 	$2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to )
# Example:
# 	test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}

# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
	local first_option all_short_options='NLGFRDCZTIhv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_qb_name=
_arg_qb_category=
_arg_qb_tags=
_arg_qb_content=
_arg_qb_root=
_arg_qb_save=
_arg_qb_num=
_arg_qb_size=
_arg_qb_tracker=
_arg_qb_hash=

# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help ()
{
	printf '%s\n' "qbittorrent filebot postprocess script"
	printf 'Usage: %s [-N|--qb_name <arg>] [-L|--qb_category <arg>] [-G|--qb_tags <arg>] [-F|--qb_content <arg>] [-R|--qb_root <arg>] [-D|--qb_save <arg>] [-C|--qb_num <arg>] [-Z|--qb_size <arg>] [-T|--qb_tracker <arg>] [-I|--qb_hash <arg>] [-h|--help] [-v|--version]\n' "$0"
	printf '\t%s\n' "-N,--qb_name: torrent name (no default)"
	printf '\t%s\n' "-L,--qb_category: torrent category (no default)"
	printf '\t%s\n' "-G,--qb_tags: separated by comma (no default)"
	printf '\t%s\n' "-F,--qb_content: content path, same as root for multifile torrent (no default)"
	printf '\t%s\n' "-R,--qb_root: root path, first torrent subdirectory path (no default)"
	printf '\t%s\n' "-D,--qb_save: save path (no default)"
	printf '\t%s\n' "-C,--qb_num: number of files (no default)"
	printf '\t%s\n' "-Z,--qb_size: torrent size (bytes) (no default)"
	printf '\t%s\n' "-T,--qb_tracker: current tracker (no default)"
	printf '\t%s\n' "-I,--qb_hash: torrent info hash (no default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
    printf '\nEnvironment variables that are supported:\n'
    printf '\t%s\n' "SCRIPTS: the default mount path for scripts. (default: '/scripts')"
}

# The parsing of the command-line
parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			# We support whitespace as a delimiter between option argument and its value.
			# Therefore, we expect the --qb_name or -N value.
			# so we watch for --qb_name and -N.
			# Since we know that we got the long or short option,
			# we just reach out for the next argument to get the value.
			-N|--qb_name)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_qb_name="$2"
				shift
				;;
			# We support the = as a delimiter between option argument and its value.
			# Therefore, we expect --qb_name=value, so we watch for --qb_name=*
			# For whatever we get, we strip '--qb_name=' using the ${var##--qb_name=} notation
			# to get the argument value
			--qb_name=*)
				_arg_qb_name="${_key##--qb_name=}"
				;;
			# We support getopts-style short arguments grouping,
			# so as -N accepts value, we allow it to be appended to it, so we watch for -N*
			# and we strip the leading -N from the argument string using the ${var##-N} notation.
			-N*)
				_arg_qb_name="${_key##-N}"
				;;
			# See the comment of option '--qb_name' to see what's going on here - principle is the same.
			-L|--qb_category)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_qb_category="$2"
				shift
				;;
			# See the comment of option '--qb_name=' to see what's going on here - principle is the same.
			--qb_category=*)
				_arg_qb_category="${_key##--qb_category=}"
				;;
			# See the comment of option '-N' to see what's going on here - principle is the same.
			-L*)
				_arg_qb_category="${_key##-L}"
				;;
			# See the comment of option '--qb_name' to see what's going on here - principle is the same.
			-G|--qb_tags)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_qb_tags="$2"
				shift
				;;
			# See the comment of option '--qb_name=' to see what's going on here - principle is the same.
			--qb_tags=*)
				_arg_qb_tags="${_key##--qb_tags=}"
				;;
			# See the comment of option '-N' to see what's going on here - principle is the same.
			-G*)
				_arg_qb_tags="${_key##-G}"
				;;
			# See the comment of option '--qb_name' to see what's going on here - principle is the same.
			-F|--qb_content)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_qb_content="$2"
				shift
				;;
			# See the comment of option '--qb_name=' to see what's going on here - principle is the same.
			--qb_content=*)
				_arg_qb_content="${_key##--qb_content=}"
				;;
			# See the comment of option '-N' to see what's going on here - principle is the same.
			-F*)
				_arg_qb_content="${_key##-F}"
				;;
			# See the comment of option '--qb_name' to see what's going on here - principle is the same.
			-R|--qb_root)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_qb_root="$2"
				shift
				;;
			# See the comment of option '--qb_name=' to see what's going on here - principle is the same.
			--qb_root=*)
				_arg_qb_root="${_key##--qb_root=}"
				;;
			# See the comment of option '-N' to see what's going on here - principle is the same.
			-R*)
				_arg_qb_root="${_key##-R}"
				;;
			# See the comment of option '--qb_name' to see what's going on here - principle is the same.
			-D|--qb_save)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_qb_save="$2"
				shift
				;;
			# See the comment of option '--qb_name=' to see what's going on here - principle is the same.
			--qb_save=*)
				_arg_qb_save="${_key##--qb_save=}"
				;;
			# See the comment of option '-N' to see what's going on here - principle is the same.
			-D*)
				_arg_qb_save="${_key##-D}"
				;;
			# See the comment of option '--qb_name' to see what's going on here - principle is the same.
			-C|--qb_num)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_qb_num="$2"
				shift
				;;
			# See the comment of option '--qb_name=' to see what's going on here - principle is the same.
			--qb_num=*)
				_arg_qb_num="${_key##--qb_num=}"
				;;
			# See the comment of option '-N' to see what's going on here - principle is the same.
			-C*)
				_arg_qb_num="${_key##-C}"
				;;
			# See the comment of option '--qb_name' to see what's going on here - principle is the same.
			-Z|--qb_size)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_qb_size="$2"
				shift
				;;
			# See the comment of option '--qb_name=' to see what's going on here - principle is the same.
			--qb_size=*)
				_arg_qb_size="${_key##--qb_size=}"
				;;
			# See the comment of option '-N' to see what's going on here - principle is the same.
			-Z*)
				_arg_qb_size="${_key##-Z}"
				;;
			# See the comment of option '--qb_name' to see what's going on here - principle is the same.
			-T|--qb_tracker)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_qb_tracker="$2"
				shift
				;;
			# See the comment of option '--qb_name=' to see what's going on here - principle is the same.
			--qb_tracker=*)
				_arg_qb_tracker="${_key##--qb_tracker=}"
				;;
			# See the comment of option '-N' to see what's going on here - principle is the same.
			-T*)
				_arg_qb_tracker="${_key##-T}"
				;;
			# See the comment of option '--qb_name' to see what's going on here - principle is the same.
			-I|--qb_hash)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_qb_hash="$2"
				shift
				;;
			# See the comment of option '--qb_name=' to see what's going on here - principle is the same.
			--qb_hash=*)
				_arg_qb_hash="${_key##--qb_hash=}"
				;;
			# See the comment of option '-N' to see what's going on here - principle is the same.
			-I*)
				_arg_qb_hash="${_key##-I}"
				;;
			# The version argurment doesn't accept a value,
			# we expect the --version or -v, so we watch for them.
			-v|--version)
				echo "$(basename "$0")" v"$version"
				exit 0
				;;
			# We support getopts-style short arguments clustering,
			# so as -v doesn't accept value, other short options may be appended to it, so we watch for -v*.
			# After stripping the leading -v from the argument, we have to make sure
			# that the first character that follows coresponds to a short option.
			-v*)
				echo "$(basename "$0")" v"$version"
				exit 0
				;;
			# See the comment of option '--version' to see what's going on here - principle is the same.
			-h|--help)
				print_help
				exit 0
				;;
			# See the comment of option '-v' to see what's going on here - principle is the same.
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash
test -n "$SCRIPTS" || SCRIPTS="/scripts"

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# FileBot Configuration
shopt -s nocasematch
test -n "$OUT_DIR" || OUT_DIR="."
test -n "$FILEBOT" || FILEBOT=$(which filebot) || FILEBOT="/usr/bin/filebot"
test -n "$PPR_LOG" || PPR_LOG=/config/postprocess.log
MEDIA_OUTPUT="$OUT_DIR/Media"

log() {
    echo "$(date -Iseconds) [$(basename "$0")]: $*" | tee -a "$PPR_LOG"
}

log "-------------------------------------"
log "--- RUN $(date -Iseconds) ---"
log "Value of SCRIPTS: $SCRIPTS"
log "Value of OUT_DIR: $OUT_DIR"
log "Value of FILEBOT: $FILEBOT"
log "Value of --qb_name:        $_arg_qb_name"
log "Value of --qb_category:    $_arg_qb_category"
log "Value of --qb_tags:        $_arg_qb_tags"
log "Value of --qb_content:     $_arg_qb_content"
log "Value of --qb_root:        $_arg_qb_root"
log "Value of --qb_save:        $_arg_qb_save"
log "Value of --qb_num:         $_arg_qb_num"
log "Value of --qb_size:        $_arg_qb_size"
log "Value of --qb_hash:        $_arg_qb_hash"

# TODO: https://www.filebot.net/forums/viewtopic.php?p=43015#p43017
# The --def ut_kind=single option instructs the amc script to use both
# ut_dir and ut_file to create a file path, and that requires both of
# these options to be set, and AFAIK is only useful for uT integration.
# [[ $_arg_qb_num -eq 1 ]] && _qb_multi="single" || _qb_multi="multi"
_qb_multi="multi"
log "Value of _qb_multi:        $_qb_multi"

[[ "$_arg_qb_category" =~ (tv_shows|tv|anime|movies|movie) ]] || \
    { log 'FileBot not handling this category, skipping' ; exit 0; }

# LINKS=("$(find "$_arg_qb_root" -type l)")
# NOT reliable and returns array of length 1 even when empty

# https://stackoverflow.com/a/54561526/4078543
mapfile -d '' LINKS < <(find "$_arg_qb_root" -type l -print0)
if [[ "${#LINKS[@]}" -gt 0 ]]
then
    log 'Links found in torrent directory, skipping'
    exit 0
fi

# PAUSE the torrent before processing
set -x
http --pretty=format --headers --ignore-stdin ":${WEBUI_PORT}/api/v2/torrents/pause" hashes=="$_arg_qb_hash"
set -x

FB=("$FILEBOT" -script fn:amc --action keeplink --output "$MEDIA_OUTPUT" --conflict skip \
--filter \"'!readLines('\'"$SCRIPTS"'/excludes.txt'\'').contains(n)'\" \
-non-strict --log-file amc.log --def excludeList=".excludes" \
--def ut_dir="$_arg_qb_root" ut_kind="$_qb_multi" ut_title="$_arg_qb_name" ut_label="$_arg_qb_category" \
--def @"$SCRIPTS"/notify.txt \
--def minLengthMS=300000 \
--def movieDB=TheMovieDB seriesDB=TheMovieDB::TV animeDB=AniDB musicDB=ID3 \
--def movieFormat=@"$SCRIPTS"/movieFormat.groovy \
--def seriesFormat=@"$SCRIPTS"/seriesFormat.groovy \
--def animeFormat=@"$SCRIPTS"/animeFormat.groovy)

log "${FB[@]}"

# sudo -H -u devster -g devster --
"${FB[@]}"

# RESTART the torrent after processing
set -x
http --pretty=format --headers --ignore-stdin ":${WEBUI_PORT}/api/v2/torrents/resume" hashes=="$_arg_qb_hash"
set +x

# ] <-- needed because of Argbash